# A
首先把整个数组只操作一次肯定是一中方案，然后我们找出所有当前颜色的连续段，检查用多一次操作的代价来减少连续段长度的情况是否更优，注意特判连续段在首尾的情况

# B

# C

首先我们考虑 $a$ 与 $b/g$,其中 $g=\gcd(a,b)$，这里显然满足 $\gcd(a,b/g)=1$ 但是如果有 $b=g$ 则 $\gcd(b,1)=1$，能过样例，但是交上去发现过不了。 原因是 $\gcd(a,b/g)$ 不一定为 1，例如对于 2 4 就不成立，所以我们需要找到一个 $x$ 为 $b/g$ 的因子，同时与 $a$ 互质，这里发现问题是可以递归解决的，写一下即可。

# D

观察数据范围 $n=30$ 意识到复杂度大概是 $\binom{n}{n/2}$ 级别算法，猜测当乘法与加法的选择确定后，一定是先算较大的值更优，最后写一个搜索搜一下乘法跟加法的顺序即可。

# E

一个非常显然的状压dp， $F[s][x]$ 表示当前打完的状态是 $s$，光标停在 $x$ 字符后的状态，直接按照题意转移即可。

注意初始化 $F[0][0]=0$ 以及初始光标落在 a。

注意数组要把较小维开在前面。

# F

赛时没做出来很可惜，关键是要想到这是个可以模拟的过程，对于后手走过的路程，我们能确定的找出先手需要如何封堵才可以迫使后手走这段路程，在dfs的过程中维护一个变量表示走到当前阶段先手还有几个自由操作次数，随后先手可以用这些次数从大到小封锁路线，使得后手走向不同的儿子，一直到叶子游戏结束，如果先手还有空闲的自由操作次数的话，先手可以把这些次数从大到小的选取剩下可自由选取的点，用权值线段树或者平衡树维护即可。

# G
只有 $a_1$ $a_n$ 最大最小值不能被删除，其他都能删，判断一下最大最小值是不是在开头结尾就行。

# H

# I

手玩一下 $k=1$ 的情况，发现是相当于交换两个数，对于 $k=2$ 的情况，情况比较复杂，$b[1,2,3,4]$ 操作过后变成了 $b[1+3-2,3,2,2+4-3]$。没有规律，想到这种操作与 mod k 的同余类相关，手玩一下发现 mod k 的同余类值的总和不随着操作改变而改变，验证更大的 k 依然有这个性质。

每次操作我们正好会访问 k 个同余类，每个同余类中改变了两个数 x与 x+1 所在的位置是交换，其他位置的数是根据和不变确定的。

我们对同余类内部进行求和，由和不变过程故每个同余类内部的前缀和只改变一个数，且这些改变的位置在原来数组上连续，所以能想到差分，手玩一下发现相当于交换  $d_i,d_{i-k}$ ，用并查集维护连通块即可。

# J

直接对每个位置按照最少补几个字符凑成lose来操作。

# K

狗屎分讨。

# M

首先注意到时间的范围是假的， $O(n)$ 秒后就会只剩一个块了。

所以可以直接模拟每一秒的情况，用链表维护