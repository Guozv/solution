# F

真是简单题。。。

首先需要注意到我们从重的开始考虑，每次贪心的将当前物品放入剩余空间最大的背包，也就是放物品最少的背包中。

然后我们从大到小贪心。

对于重量相同的数我们一起考虑。
对于最重的那个物品，我们会让总容量变成 $\lceil\frac{a}m \rceil$，然后会剩下 $2^{b} \cdot (a \bmod m)$ 的容量。

对于下一个物品，我们先考虑利用上一个物品所留下来的容量。

当我们要扩大背包总容量的时候，我们可以发现，此时所有背包的容量等正好等于最大容量，所以又回到了初始的情况。

我们只需要维护一个变量 sum 表示上一个物品还留下了多少容量给我们。

这里由于值太大，我们只能存储 $2^b$ 前方的系数。

但是当我们从一个数跳到另个数的时候，这个系数会超过整形范围，但是可以发现，如果这个差值太大，我们可以用当前剩余容量装下剩下的所有物品，上线是 $2\cdot 10^{14}$，判断一下即可。

# C

有点复杂的分讨、

一个并不难的题，首先这个题一定是有周期的，一个来回 2n-1 为一个周期

对于一块草，我们分析它在什么时候会被砍。

首先第一次到 n 的时候，所有的草都会被砍

然后回来的时候，如果 a_i%T 大于 (n-i)*2 那回来的时候不会被割,也就是只会在去的时候被割

如果 a_i%T 大于等于 (i-1)*2+1 那说明再一次去的时候也不会被割，只会在回来的时候被割

否则去跟回都会被割。

然后注意特殊处理一下 a[n] 

枚举这个间隔的周期数统计答案，复杂度调和级数

# J

ez 串串啊

可以想到sa，每次就是把与 l 这个后缀 lcp 长度大于等于 r-l+1 的后缀长度砍到  r-l+1 ，明显的区间推平操作，直接做会有重复，我们维护 n-sa[i]+1-hi[i]，这样我们每次都是推平的与前面不同的部分。

每次推平区间 [L,R]，先计算答案，对 [L+1,R] 区间求和 ，L 处的 值与 r-l+1-hi[L] 取min 并计算贡献。容易发现这是区间赋 0 操作，可以色段均摊，当然线段树也是可以的。

复杂度单 log



